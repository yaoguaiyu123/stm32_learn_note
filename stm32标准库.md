# 背景

研0

**纯软基础**：学过C/C++ ，linux，linux系统编程网络编程，Qt/Qml

**转嵌软（MCU + linux）**：目前学了51单片机，部分数电知识，正在学习stm32

课程：江科大stm32



# Keil μVision 5 代码补全时候卡死

**解决方法**：关掉电脑上的杀毒软件、电脑管家、安全卫士等等（关掉之后还是会有卡顿，但是不至于卡死）

这idea真垃圾，但是现在懒得换，等学完江科的就去换成vscode



# Keil μVision 5转vscode==（失败）==

参考了如下文章：

https://blog.csdn.net/2401_85729082/article/details/153967578

遇到烧录问题，DAPmini在选择OpenOCD之后不能烧录

| **软件**              | **喜欢的驱动模式** | **特点**                     | **现状**                             |
| --------------------- | ------------------ | ---------------------------- | ------------------------------------ |
| **Keil**              | **HID 模式**       | 慢一点，但兼容性好，插上即用 | 电脑现在就是这个模式，所以 Keil 能用 |
| **VS Code (OpenOCD)** | **WinUSB 模式**    | 速度快，支持 CMSIS-DAP v2    | 电脑缺这个驱动，所以 OpenOCD 罢工    |

## 方法1
使用**Zadig** 软件把所有相关的驱动（Driver）从 `HIDUSB` 改成 **`WinUSB`**

==最后失败了==

## 方法2

自己配置烧录cfg文件

```bash
*# 引用官方的 cmsis-dap 配置*

source [find interface/cmsis-dap.cfg]

*# 强制使用 HID 模式*

cmsis_dap_backend hid

```

烧录之后停在断点

# 基础知识

## STM32 

一类 32 位的 ARM 微控制器（MCU），使用 ARM 公司设计的 Cortex-M 内核

## ARM是什么

ARM既指ARM公司，也指ARM处理器内核

ARM公司是全球领先的半导体知识产权（IP）提供商，全球超逾95%的智能手机和平板电脑都采用ARM架构

ARM公司设计ARM内核，半导体厂商完善内核周边电路并生产芯片

ARM公司设计**A系列，R系列，M系列**内核

## 我的STM32

芯片：STM32F103C8T6

主频：72MHz

存储：20KB SRAM（RAM） + 64KB Flash（ROM）

## 总线是什么

总线（Bus） = 电子系统内部用来“传输数据”的高速通道

不同芯片内部模块之间、模块和存储器之间、模块与外设之间，都需要通过总线通信

## 串口是什么

https://zhuanlan.zhihu.com/p/1915485932267771322

**串口（Serial Port）= 一种按“位（bit）”顺序发送数据的通信方式。数据一位挨一位地传输，而不是一字节同时传输。**

常见的串口协议：

| 类型              | 全称                                                    | 用途                           |
| ----------------- | ------------------------------------------------------- | ------------------------------ |
| **UART**          | Universal Asynchronous Receiver/Transmitter             | MCU 与传感器通信、调试信息输出 |
| **USART**         | Universal Synchronous/Asynchronous Receiver/Transmitter | UART + SPI 特性                |
| **RS-232**        | PC 上传统串口接口                                       | 老设备、工业设备               |
| **RS-485**        | 工业设备远距离通信                                      | 电机控制、PLC、仪表            |
| **TTL UART**      | 微控制器串口                                            | Arduino、STM32、51、ESP32      |
| **Bluetooth SPP** | Serial Port Profile                                     | 蓝牙模拟串口，用于无线通信     |

## 时钟是什么

**一句话理解**

- 在电子工程里，时钟 = 芯片里所有电路运行的节奏信号，不是用来看时间的，是“节拍器”，不是“钟表”

在音乐里见过节拍器吧？嘀、答、嘀、答......节奏越快，演奏越快

**单片机内部的数字电路也是一样的：
每个功能都需要一个节奏来驱动它运行。**

例如：

- CPU 每个时钟周期执行一步指令
- UART 每个时钟周期发送一位
- I2C、SPI 的协议节奏也靠时钟
- ADC 每个时钟周期采样
- 定时器用时钟计数
- USB 必须固定 48MHz 时钟才能通信

==所以“时钟”在 MCU 里其实是一种节奏信号==

# 开始开发

## 环境搭建

- Kei5 MDK + 软件支持包（Keil.STM32F1xx_DFP.2.2.0.pack）

- STLINK驱动 ：**ST-Link 是 STM32 官方的“下载器 + 调试器”**，它能让电脑把程序写入 STM32，也能实时调试单片机内部运行情况，就像给 STM32 插上一根“数据和调试的 USB 线”。

> 我的则是**DAP mini，是一种便宜、小巧、通用的 ARM 调试器（SWD 下载器 + 调试器），**
>  它使用 **CMSIS-DAP 协议**，是 ARM 官方标准协议，因此兼容性很好。它的作用类似于 **ST-Link / J-Link**，但更便宜、通用性更强，==不需要安装驱动==

- USB转串口驱动：是让电脑识别 CH340 芯片为 COM 口的驱动程序

## 开发方式

- 寄存器
- 库函数==（选择该方式进行开发）==
- HAL库

## startup_stm32f10x_xx.s 文件是什么

这些都是 STM32F10x 系列的**启动文件**（Startup File / 启动汇编）

它们负责 MCU 上电后最核心的事情：

1. 负责中断向量表（Vector Table）
   - Reset_Handler
   - HardFault_Handler
   - SysTick_Handler
   - 各种外设中断入口

2. 负责设置堆栈指针 SP

3. 调用 SystemInit()，再跳转到 main()

> 不同的启动文件对**不同 Flash 容量**的芯片做了微调，我选择startup_stm32f10x_md.s

## 连接STM32最小系统板和DAPmini

| STM32 引脚 | 名称     |
| ---------- | -------- |
| GND        | 地线     |
| SWCLK      | 调试时钟 |
| SWDIO      | 调试数据 |
| 3V3        | 电源     |

| DAPmini引脚              | 作用                 |
| ------------------------ | -------------------- |
| GND (Pin7/Pin8)          | 地线（必须接）       |
| SWDCLK (Pin5)            | SWD 时钟线           |
| SWDIO (Pin9)             | SWD 数据线           |
| 3.3V (Pin3) or 5V (Pin1) | 给目标板供电（可选） |

==调试器选择：CMSIS-DAP Debugger==

## 新建工程的步骤

1. 建立工程文件夹，新建工程，选择型号
2. 工程文件夹里建立Start（启动文件的选择由芯片的型号决定）、Library、User等文件夹，复制固件库里面的文件到工程文件夹
3. 工程里对应建立Start、Library、User等同名称的分组，然后将文件夹内的文件添加到工程分组里
4. 工程选项--->C/C++，Include Paths内声明所有包含头文件的文件夹工程选项
5. 工程选项--->C/C++，Define内定义`USE_STDPERIPH_DRIVER`
6. 工程选项--->Debug，下拉列表选择对应调试器`CMSIS-DAP Debugger`；Settings，Flash Download里勾选Reset and Run

# 如何看懂"寄存器方式"的代码

## 1️⃣先搞清楚“这个寄存器属于哪个外设”

比如：

- `RCC->APB2ENR` → RCC 模块
- `GPIOC->CRH` → GPIO 模块
- `USART1->BRR` → 串口模块

## 2️⃣ 打开 STM32F10xxx参考手册（中文）.pdf，跳到对应外设章节

目录一般是这样：

- 7.3 GPIO
- 7.4 RCC
- 8.x USART
- 9.x SPI

## 3️⃣ 在这一章里找“寄存器列表”

会有一张表：列出这个外设所有寄存器和偏移地址

找到要的那个，比如 `GPIOx_CRH`

## 4️⃣ 看该寄存器的 **位定义表**

比如：

| Bit   | Name                    | Description   |
| ----- | ----------------------- | ------------- |
| 23:20 | CNF13[1:0], MODE13[1:0] | Portx.13 配置 |

## 5️⃣把十六进制数拆成二进制/按位理解

例如：

```
GPIOC->CRH = 0x00300000;
```

- 算出它哪几位是 1
- 对照位表对应到含义上

# GPIO

GPIO = General Purpose Input/Output（ 通用输入输出） ：**“通用输入输出端口”，就是 MCU 上最基本、最常用、能读能写的“引脚”**

- **功能1：**输出模式下可控制端口输出高低电平，用以驱动LED、控制蜂鸣器、模拟通信协议输出时序等

- **功能2：**输入模式下可读取端口的高低电平或电压，用于读取按键输入、外接模块电平信号输入、ADC电压采集、模拟通信协议接收数据等

## GPIO基本结构

https://www.cnblogs.com/Sharemaker/p/17107060.html

## GPIO 外设模块

GPIOA / GPIOB / GPIOC 是“GPIO 外设模块”

每个 GPIO 外设模块内部包含一组寄存器（ODR/IDR/CRL/CRH/BSRR/BRR 等）

通过 `GPIOx->寄存器` 来操作引脚

一个外设模块（如`GPIOB`） = 一组寄存器的集合

- 配置类寄存器：决定外设的模式与能力
- 控制类寄存器：实际驱动外设动作
- 输入类寄存器：读取外设状态 

# LED点灯例子

## STM32F103的总线与外设

STM32F103内部有三个外设总线：

```
AHB：高速外设（DMA、存储器）
APB1：低速外设（USART2、TIM2、I2C1…）
APB2：高速外设（GPIO、USART1、ADC1…）
```

外设挂在 AHB / APB1 / APB2 三条外设总线上，总线是 STM32 外设运行的“交通道路”

STM32 的总线（AHB/APB1/APB2）`时钟`本来就一直在工作，STM32 外设必须先开时钟才能工作

- 所以`LED 点灯 = 开启 GPIOA 外设模块的时钟 + 配置 PA0 为推挽输出 + 拉低 PA0 的电平`（我使用的是 GPIOA模块 与 PA0引脚）

时钟的开启和复位由 **RCC (Reset and Clock Control)** 模块控制

> RCC 是 STM32 芯片内部的一个独立硬件模块，负责整个芯片的时钟与复位管理，并为所有外设提供时钟，任何外设在使用前必须先通过 RCC 打开对应时钟

- 所以**开启/关闭具体外设的时钟**的函数的开头都是RCC

```c
  void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState);
  void RCC_APB2PeriphClockCmd(uint32_t RCC_APB2Periph, FunctionalState NewState);
  void RCC_APB1PeriphClockCmd(uint32_t RCC_APB1Periph, FunctionalState NewState);
```

==注意我的LED灯设备中，短引脚是负极，长引脚是正极==

## 推挽输出 VS 开漏输出

**推挽输出GPIO_Mode_Out_PP**：引脚能主动输出 **高电平** 和 **低电平**

**开漏输出GPIO_Mode_Out_OD**：引脚只能主动输出 **低电平**，高电平需要 **外部电阻拉起来**

# GPIO常用的输入输出标准库函数

## 输出

```c
void GPIO_SetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);

void GPIO_ResetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);

void GPIO_WriteBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, BitAction BitVal);

void GPIO_Write(GPIO_TypeDef* GPIOx, uint16_t PortVal);
```
## 读取输入
```c
//读取 PA0~PA15 所有输入
uint16_t GPIO_ReadInputData(GPIO_TypeDef* GPIOx);

//读取指定引脚输入电平
uint8_t GPIO_ReadInputDataBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);
```

## 读取输出寄存器的输出状态

```c
uint16_t GPIO_ReadOutputData(GPIO_TypeDef* GPIOx);

uint8_t GPIO_ReadOutputDataBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);
```

# GPIO外设模块直接控制引脚电平的寄存器

## ODR（Output Data Register）

### 直接控制 GPIO 输出电平

操作例子：

```
GPIOA->ODR |= (1 << 5);    // PA5 输出高电平
GPIOA->ODR &= ~(1 << 5);   // PA5 输出低电平
```

会直接改变引脚电平

> 不推荐用于单个位操作（有读改写风险）

## BSRR（Bit Set/Reset Register）

### 最推荐控制引脚电平的寄存器

- 低 16 位：置 1（设为高电平）
- 高 16 位：置 0（设为低电平）

例如：

```
GPIOA->BSRR = (1 << 5);        // PA5 = 1
GPIOA->BSRR = (1 << (5 + 16)); // PA5 = 0
```

原子操作

> 标准库 GPIO_SetBits / GPIO_ResetBits / GPIO_WriteBit 都基于 BSRR

##  BRR（Bit Reset Register）

### 用于清零对应的引脚（输出低电平）

```
GPIOA->BRR = (1 << 5); // PA5 = 0
```

专门用于复位（置 0）

# OLED显示屏

> 跟着视频做之后显示屏不亮，将GPIOB的引脚8和9从**开漏输出**修改到**推挽输出**后解决

# 中断

中断是STM32 在运行主程序时，被“外部事件”或“内部事件”打断，跳去执行一段专门的函数（中断服务函数），执行完再回到原来位置继续跑

## 中断分类

### 外部中断（EXTI）

来自 MCU 外部的信号，例如：

- **按键按下（PA0）**
- 传感器信号
- 引脚电平变化（上升沿/下降沿）

经典例子：

```
PA0 按键按下 → 触发 EXTI0 → 执行 EXTI0_IRQHandler()
```

https://www.cnblogs.com/Xa-L/p/17552096.html****

### 内部外设中断

来自 STM32 内部硬件的事件，例如：

- **定时器溢出（TIM2 update）**
- **串口收到数据（USART1 RXNE）**
- **ADC 转换完成（ADC1 EOC）**
- DMA 完成
- SPI 通信事件
- I2C 事件

## NVIC（中断控制器）

### 中断要由 **NVIC（Nested Vectored Interrupt Controller）** 管理：

- 管理优先级（共16个优先级）
- 管理开/关
- 决定哪个中断先执行

### **NVIC 用 4 位优先级字段**

-  高 n 位 = 抢占优先级（决定能否中断其他中断）

- 低 4-n 位 = 响应优先级（决定排队顺序）

-  抢占优先级越小 → 越能抢占别人

-  抢占优先级相同时 → 响应优先级小的先执行

-  两者都相同时 → 按中断号排序执行

> **抢占优先级**：决定谁能“打断谁”，用于中断嵌套
>
> **响应优先级**：决定在同一抢占优先级下，谁先执行（排队顺序）

# EXTI与AFIO

## EXTI 是什么

EXTI 全称：

> **External Interrupt/Event Controller
>  外部中断/事件控制器**

它的作用：

> **把 GPIO 引脚的电平变化（上升沿、下降沿）转换成中断事件**

简单理解：

- GPIO 引脚变化 → 送给 EXTI
- EXTI 判断是否满足触发条件
- 满足 → 产生 EXTI 中断
- NVIC 处理中断

## EXTI 的输入来源是什么？

STM32F103 总共有 16 条 EXTI 线：

```
EXTI0 ~ EXTI15
```

每一条 EXTI 线 **可以接某一个 GPIO 引脚**：

- EXTI0 ← PA0 / PB0 / PC0 / PD0（四选一）
- EXTI1 ← PA1 / PB1 / PC1 / PD1（四选一）
- EXTI2 ← PA2 / PB2 / PC2 / PD2（四选一）
   …

> STM32 的 EXTI 线是 **按引脚序号，而不是端口** 进行索引的。

例如：

- PA0 → EXTI0
- PA1 → EXTI1
- PB0 → EXTI0
- PC0 → EXTI0

## EXTI 本身不能决定“用哪个 GPIO 引脚”

这就是 **AFIO 的作用**。

## AFIO 是什么？

AFIO = Alternate Function I/O
 **复用功能配置模块**

它是用来：

> **把某个 GPIO 引脚连接映射到某条 EXTI 线上的。**

也就是说：

> **AFIO 决定 GPIOx.y → 接到 EXTIy。**

## AFIO 怎么实现 GPIO → EXTI 的映射？

在 AFIO 模块里，有一个寄存器：

```
AFIO->EXTICR[0..3]
```

每个 EXTICR 寄存器控制 4 条 EXTI 线：

```
EXTICR0 → EXTI0, EXTI1, EXTI2, EXTI3
EXTICR1 → EXTI4~EXTI7
EXTICR2 → EXTI8~EXTI11
EXTICR3 → EXTI12~EXTI15
```

每条EXTI 线 4 位，用于选择端口：

| 数值 | 意义       |
| ---- | ---------- |
| 0000 | 选择 GPIOA |
| 0001 | 选择 GPIOB |
| 0010 | 选择 GPIOC |
| 0011 | 选择 GPIOD |

让 **PB0 触发 EXTI0**：

```c
AFIO->EXTICR[0] &= ~(0xF << 0);  // 清 EXTI0 的 4 位
AFIO->EXTICR[0] |=  (0x1 << 0);  // 选择 PB0（0001）
```

让 **PB1 触发 EXTI1**：
```c
AFIO->EXTICR[0] &= ~(0xF << 4);  // 清 EXTI1 的 4 位
AFIO->EXTICR[0] |=  (0x1 << 4);  // 选择 PB1（00010000）
```

## EXTI 与 AFIO 的关系一句话总结：

> **EXTI 是中断“引擎”（检测边沿 + 产生中断请求）**
>
> **AFIO 是 GPIO 到 EXTI 的“路由器”**

![image-20251128003824974](./assets/image-20251128003824974.png)

# EXTI与NVIC

> **EXTI 是中断“引擎”（产生中断请求）**
>
> **NVIC 是中断“调度器 / 管理中心”**

NVIC 接受到 EXTI 的中断请求后，会根据优先级调度各个请求

当轮到一个请求，例如轮到 EXTI0 时，就会跳转执行 `EXTI0_IRQHandler()` —— 而这个函数是程序员定义的

```c
void EXTI0_IRQHandler(void)
{
    if (EXTI_GetITStatus(EXTI_Line0) != RESET)
    {
        // 用户代码，例如翻转 LED
        EXTI_ClearITPendingBit(EXTI_Line0);
    }
}

```

# 定时器

https://blog.csdn.net/qq_38410730/article/details/79976785

## 定时器是什么
定时器就是一个可调节速度的计数器，数到指定值后会触发事件（中断 / PWM / 捕获等）。

| 定时器   | 类型 | 位宽      | 互补 PWM | 死区 | 编码器 | 通道数        | 用途             |
| -------- | ---- | --------- | -------- | ---- | ------ | ------------- | ---------------- |
| **TIM1** | 高级 | 16 位     | ✔        | ✔    | ✔      | CH1~CH4(含 N) | 电机、复杂 PWM   |
| **TIM2** | 通用 | **32 位** | ✘        | ✘    | ✔      | 4             | 长计数、时间测量 |
| **TIM3** | 通用 | 16 位     | ✘        | ✘    | ✔      | 4             | 普通 PWM/捕获    |
| **TIM4** | 通用 | 16 位     | ✘        | ✘    | ✔      | 4             | 普通 PWM/捕获    |

## 定时器的计数时钟来源

| 序号  | 时钟来源        | 说明                     | 用途               |
| ----- | --------------- | ------------------------ | ------------------ |
| **1** | 内部时钟 CK_INT | 来自 APB 分频的内部时钟  | 普通定时、PWM      |
| **2** | 外部时钟模式 1  | ETR 引脚触发 CNT         | 外部脉冲计数       |
| **3** | 外部时钟模式 2  | TI1/TI2 输入脉冲触发 CNT | 频率测量、脉冲计数 |
| **4** | 内部触发源 ITR  | 其他定时器的事件         | 定时器同步         |
| **5** | 编码器模式      | A/B 相决定 CNT 增减      | 读取编码器         |

# 通用定时器的工作原理

## 1️⃣ **时钟源进入定时器**

定时器的输入时钟来自：

- APB1 或 APB2 总线时钟
- 当 APB 分频器不是 1 时，会 ×2（这是 STM32 的特殊优化）

例如：

- TIM2/3/4 在 APB1：36MHz 或 72MHz（可能 ×2）
- TIM1 在 APB2：72MHz

## 2️⃣ **预分频器 PSC 分频**

定时器不能直接用几十 MHz 的时钟太快，所以 PSC 对其分频：

```
CK_CNT = CK_INT / (PSC + 1)
```

得到一个你需要的速度（计数周期）。

比如：

```
PSC = 71
→ 定时器计数频率 = 72MHz / 72 = 1MHz（1µs 加一）
```

## 3️⃣ **计数器 CNT 按节拍不断计数**

预分频器处理后的时钟信号驱动 **CNT（计数器）**：

- CNT 每来一个脉冲 +1（递增模式）
- 或 -1（递减模式）
- 或在中间“中心对称计数”（PWM 时常用）

这是整个定时器最核心的行为：
 **CNT 在“按固定速度不断走”**

## 4️⃣ **CNT 与 ARR（自动重装载值）比较**

ARR 决定 CNT 计数的最大值（或最小值）：

```
当 CNT 数到 ARR：
    CNT 自动清零
    触发更新事件（Update Event）
```

这个更新事件可以用于：

- 产生定时中断（最常见）
- 触发 PWM 更新
- 自动产生 DMA 请求
- 同步触发其他外设

## 5️⃣ **事件触发（中断、PWM、OC、IC）**

当 CNT 到达 ARR 或达到某个比较值时，通用定时器能产生多种事件：

### ✔ 更新中断（TIM_IT_Update）

最常用，CNT 溢出就进一次中断

### ✔ 输出比较（OC）

CNT 与 CCRx 匹配时触发事件

### ✔ PWM 输出

CNT 在 0→ARR 的过程中比较 CCR，就能输出 PWM 波形

### ✔ 输入捕获（IC）

记录外部信号来的时刻（CNT 值）

### ✔ 外部计数模式

CNT 不再计内部时钟，改为计外部脉冲

# 定时中断

![image-20251128145638936](.\assets\image-20251128145638936.png)

## 定时中断的分类

### **1️⃣ 更新中断（Update Interrupt）**

这是定时器里最典型、最标准的定时中断。

- CNT 从 0 数到 ARR → 溢出 → 自动清零
- 产生 **更新事件（UE）**
- 如果开启更新中断，CPU 会进入 ISR

### **2️⃣输出比较中断（Output Compare Interrupt）**

这也是“定时”的一种方式，只是比更新中断更灵活。

- CNT 会不停地计数
- 当 CNT == CCRx（比较寄存器）时 → 触发 **比较中断**

可以每次比较后 **动态更新 CCR**，实现精确的定时间隔

### 其他中断

> 以下虽然属于定时器中断，但不是用于“定时”的，它们不是周期性时间触发事件，而是事件驱动的

| 中断类型            | 是否属于定时中断 | 解释                               |
| ------------------- | ---------------- | ---------------------------------- |
| 输入捕获中断（IC）  | ❌ 否             | 捕获外部信号跳变，不用于周期性定时 |
| 触发事件中断（TRG） | ❌ 否             | 定时器同步用途                     |
| 编码器中断          | ❌ 否             | 由外部 A/B 相触发                  |
| 通道溢出中断        | ❌ 否             | 输入捕获 FIFO 相关                 |

# 输出比较与PWM波形图

输出比较的其中一个作用就是通过不断更新 CCR 实现更精准的定时中断，在`输出比较中断`中已经提到过

另一个作用是生成`PWM波形`

## 输出比较的各个模式

| 模式             | 描述                                                         |
| ---------------- | ------------------------------------------------------------ |
| 冻结             | CNT = CCR 时，REF 保持为原状态                               |
| 匹配时置有效电平 | CNT = CCR 时，REF 置为有效电平                               |
| 匹配时置无效电平 | CNT = CCR 时，REF 置为无效电平                               |
| 匹配时电平翻转   | CNT = CCR 时，REF 电平翻转                                   |
| 强制为无效电平   | CNT 与 CCR 无关，REF 强制为无效电平                          |
| 强制为有效电平   | CNT 与 CCR 无关，REF 强制为有效电平                          |
| PWM 模式 1       | 向上计数：CNT < CCR 时，REF 置有效电平；CNT ≥ CCR 时，REF 置无效电平 |
|                  | 向下计数：CNT > CCR 时，REF 置无效电平；CNT ≤ CCR 时，REF 置有效电平 |
| PWM 模式 2       | 向上计数：CNT < CCR 时，REF 置无效电平；CNT ≥ CCR 时，REF 置有效电平 |
|                  | 向下计数：CNT > CCR 时，REF 置有效电平；CNT ≤ CCR 时，REF 置无效电平 |



## PWM波形

![img](https://i-blog.csdnimg.cn/blog_migrate/7fa05bd09e4a123750b402addcfbd73e.png)

## 输出比较如何生成 PWM 波形（以 PWM1 为例）

###  与 PWM1 模式相关的寄存器
- **ARR（Auto Reload Register）**：决定 PWM 周期
- **CCR（Capture/Compare Register）**：决定 PWM 占空比
- **CNT（Counter）**：定时器计数器，一直从 0 → ARR 循环
- **OC 模式（Output Compare Mode）**：选择 PWM1 或 PWM2

### PWM1 模式的逻辑规则
PWM1 的输出电平根据 CNT 与 CCR 的关系决定：

| 条件      | 输出状态 |
| --------- | -------- |
| CNT < CCR | 高电平   |
| CNT ≥ CCR | 低电平   |

这意味着：
- CCR 决定高电平持续时间（占空比）
- ARR 决定整个周期长度

==PWM2就是PWM1反过来==

![image-20251128215711981](.\assets\image-20251128215711981.png)

##  PWM 参数计算

PWM频率：`Freq = CK_PSC / (PSC + 1) / (ARR + 1) `  ==一般是CK_PSC是72M==

PWM占空比：`Duty = CCR / (ARR + 1)`

PWM分辨率：`Reso = 1 / (ARR + 1)`

## 不同定时器对应的各个引脚⭐⭐⭐

==很重要，需要查看不同定时器的不同通道分别与哪些引脚对应==

https://blog.csdn.net/pikachu_beta/article/details/115093647

## PWM驱动舵机

![image-20251203145408260](.\assets\image-20251203145408260.png)

# 输入捕获

## 输入捕获的工作原理

### 第一步：信号输入与滤波

外部信号（比如频率未知的方波）通过 GPIO 引脚进入定时器。STM32 内部有滤波器，可以把信号上毛刺（比如抖动）过滤掉，保证信号干净。

### 第二步：边沿检测 (Edge Detect)

你需要配置定时器捕捉什么信号：

- **上升沿**（低 $\rightarrow$ 高）：测量波形的开始。
- **下降沿**（高 $\rightarrow$ 低）：测量波形的结束。
- **双边沿**：上升和下降都捕捉。

### 第三步：锁存数值 (Capture) 

当检测到设定的边沿（比如上升沿）到来的一瞬间，硬件电路会立刻执行一个操作：

$$CCR = CNT$$

即：把当前计数器（CNT）里的数值，复制到捕获寄存器（CCR）里锁存起来。

### 第四步：产生中断 (Interrupt)

同时，定时器会把标志位（CCxIF）置 1，并可以申请`中断`，告诉 CPU：“嘿！刚才有个信号来了，发生时刻是 CNT = 1000 的时候，我已经记在 CCR 里了，你快来读！”

## 输入捕获的参数计算 

![image-20251203163415824](.\assets\image-20251203163415824.png)

# TIM编码器接口

自动利用定时器的硬件电路，解析旋转编码器发出的 A、B 相信号，从而直接得出电机转了多少圈、往哪个方向转，全程不需要 CPU 参与

## 工作原理

编码器通常有两根信号线：**A 相** 和 **B 相**。它们输出的方波相位差 90°

STM32 的硬件逻辑非常聪明，它通过对比 A 和 B 的电平跳变顺序来判断方向：

- **正转**：A 相上升沿时，B 相是低电平 $\rightarrow$ 计数器 **CNT++**
- **反转**：A 相上升沿时，B 相是高电平 $\rightarrow$ 计数器 **CNT--**

而且，它支持 4倍频 (x4 Mode)：

它不仅在 A 相上升沿计数，在 A 下降、B 上升、B 下降都计数

- **好处**：精度提高 4 倍！电机轻微动一下都能被捕捉到

![image-20251203212919381](.\assets\image-20251203212919381.png)

# 模数转换器（ADC）

## STM32F103 的 ADC 功能

1. **多通道 (Channels)**：
   - 一个 ADC 模块（比如 ADC1）可以通过内部开关，依次测量多达 16 个引脚的电压（PA0, PA1, PA2...）
   - 这就叫**“扫描模式”**，像是保安巡逻一样，挨个看一眼
2. **转换速度快**：
   - 最快 1 微秒就能测一次。这意味着它可以用来采集音频信号或者高速变化的波形
3. **规则组 vs 注入组**：
   - **规则组 **：像平时的“例行体检”，按顺序一个个测
   - **注入组 **：像“急诊插队”，如果发生突发事件，可以强行插入去测量某几个重要的通道
4. **配合 DMA**：
   - 这是最高级的用法。ADC 疯狂测量，DMA 疯狂搬运，直接把数据写到内存数组里，CPU 完全不用管，直接去读数组就能拿到最新的电压值

## ADC原理

> `ADDA/B/C`决定测哪个门：`IN0-7`
> DAC生成电压二分查找，送去给比较器做对比


![image-20251204193802221](.\assets\image-20251204193802221.png)

**通道选择开关 (Multiplexer)**：

- 图左边的 `IN0` ~ `IN7`。
- 它就像一个多路岔口。因为 ADC 核心只有一个，但你想测 8 个引脚，就需要通过 `ADDA/B/C` 地址线来告诉它：“现在我要测 IN3，请把 IN3 的门打开，其他的关上。”

**逐次逼近寄存器 SAR ：**

- 这是整个 ADC 的**大脑**。
- 它负责执行上面说的“猜数字”逻辑。它不断地修改内部的数字值，试图去凑出输入电压。

**DAC (数模转换器)**：

- SAR 想出了一个数字（比如 10000000），但模拟电压听不懂数字。DAC 就负责把这个数字瞬间变成电压，送去给比较器做对比。

**比较器 ：**

- 它有两个输入端：一个是外部输入的未知电压，一个是 DAC 产生的已知电压。
- 它只输出 0 或 1，告诉 SAR：“你猜大了”或者“你猜小了”。

**8位三态锁存缓冲器**：

- 当 8 次比较全部结束，数字定下来了，SAR 会把结果存在这里。
- 当你给 `OE (Output Enable)` 引脚一个信号时，它就把大门打开，把数据 (`D0`~`D7`) 送给单片机。



## ADC执行流程

![image-20251204195000051](.\assets\image-20251204195000051.png)

## 单次转换/连续转换//扫描模式/非扫描模式

### 维度一：单次 vs 连续 (决定“看多少次”)

这是在问医生：**你看完这一轮，是停下来休息，还是立马开始下一轮？**

1. **单次转换 (Single Conversion)**
   - **逻辑**：医生看完病人后，就**下班了**（停止转换）。
   - **特点**：想再看一次？必须有人（代码或定时器）再去推一下医生（触发 START）。
   - **场景**：检测电池电量（不需要每毫秒都测，几秒测一次就行）。
2. **连续转换 (Continuous Conversion)**
   - **逻辑**：医生看完病人后，**不用休息**，立马重新开始给病人看病，周而复始，死循环。
   - **特点**：只要开始一次，后面就自动一直测，直到你喊停。
   - **场景**：示波器、音频采集（需要不间断地抓取波形）。

### 维度二：扫描 vs 非扫描 (决定“看多少人”)

这是在问医生：**你是一次只看一个特定的病人，还是按名单把所有病人都看一遍？**

1. **非扫描模式 (Scan Disable / Single Channel)**
   - **逻辑**：专科医生。只盯着 **1 个** 指定的通道（比如 PA0）测量。
   - **特点**：无论你开启多少个引脚，它只管序列里的第一个。
2. **扫描模式 (Scan Enable)**
   - **逻辑**：全科巡诊。按照你设定的“名单”（序列），**依次**测量 PA0, PA1, PA2...
   - **特点**：测完 PA0，自动测 PA1，直到名单里的最后一个人测完，才算“一轮”结束。

| **模式**       | **扫描**   | **连续 **  | **行为描述**            | **推荐搭档**   |
| -------------- | ---------- | ---------- | ----------------------- | -------------- |
| **单次单通道** | DISABLE    | DISABLE    | 测 1 个引脚，测 1 次停  | 查询 / 中断    |
| **连续单通道** | DISABLE    | **ENABLE** | 测 1 个引脚，一直测     | 查询 / DMA     |
| **单次多通道** | **ENABLE** | DISABLE    | 测 N 个引脚，测 1 轮停  | **必须用 DMA** |
| **连续多通道** | **ENABLE** | **ENABLE** | 测 N 个引脚，一直循环测 | **必须用 DMA** |

> 这些转换模式，转换完毕之后，触发EOC标志位，触发中断

# DMA

## DMA简介

**DMA 是什么？** 数据搬运工，独立于 CPU 工作

**有什么用？** 释放 CPU，让 CPU 去做更有价值的运算和逻辑控制，而不是浪费在简单的数据传输上

STM32F103只有一个 DMA 控制器：**DMA1**。

- **DMA1** 拥有 **7 个通道 (Channels)**
- 这意味着同时最多只能处理 7 个不同的搬运任务
- (注：大容量型号如 RCT6/ZET6 才有 DMA2)

| **通道 (Channel)** | **对应的外设请求**           |
| ------------------ | ---------------------------- |
| **Channel 1**      | **ADC1**, TIM2_CH3, TIM4_CH1 |
| **Channel 2**      | SPI1_RX, USART3_TX, TIM1_CH1 |
| **Channel 3**      | SPI1_TX, USART3_RX, TIM3_CH4 |
| **Channel 4**      | **USART1_TX**, I2C2_TX       |
| **Channel 5**      | **USART1_RX**, I2C2_RX       |
| **Channel 6**      | I2C1_TX, TIM3_CH1            |
| **Channel 7**      | I2C1_RX, TIM2_CH2            |

## 存储器

![image-20251204232352029](.\assets\image-20251204232352029.png)

## DMA基本结构

![image-20251205003155292](.\assets\image-20251205003155292.png)

### 1. 数据的两端：外设与存储器 (左侧与右侧)

DMA 的本质就是搬运工，它需要知道从哪里搬（源），搬到哪里去（目标）。

- **外设 (Peripheral - 左侧):**
  - 通常指 ADC、UART、SPI 等硬件接口的数据寄存器。
  - **配置要素：**
    - **起始地址 (Start Address):** 外设寄存器的内存地址（例如 `&ADC1->DR`）。
    - **数据宽度 (Data Width):** 每次搬运多大的数据（字节 Byte、半字 Half-word、字 Word）。
    - **地址是否自增 (Address Increment):** 通常外设寄存器地址是固定的（比如你一直读同一个串口数据寄存器），所以这里通常配置为**不自增**。
- **存储器 (Memory - 右侧):**
  - 通常指 **SRAM** (内存) 或 **Flash** (硬盘/代码区)。
  - **配置要素：**
    - 同样需要配置**起始地址**和**数据宽度**。
    - **地址是否自增:** 如果是往数组里存数据，每存一个数据，地址就需要往后移一位，所以这里通常配置为**自增**。

### 2. 数据流向与传输模式 (中间上部)

- **外设寄存器 <==> Flash/SRAM:**
  - 图中的黄色双向箭头表示数据可以在外设和存储器之间双向传输。
  - **方向 (Direction):** 决定了是 **P2M** (外设到存储器，如 ADC 采集) 还是 **M2P** (存储器到外设，如 UART 发送)。
- **Flash/SRAM 内部回环箭头:**
  - 这代表 **M2M (Memory to Memory)** 模式，即数据从一个内存地址搬运到另一个内存地址（例如变量拷贝），不经过外设。

### 3. 传输计数与循环控制 (中间中部)

搬运工需要知道总共要搬多少箱货。

- **传输计数器 (Transfer Counter):**
  - 这是一个倒数计数器。你设置一个值（例如 100），每传输一次数据，它就减 1。减到 0 时传输结束（或者触发中断）。
- **自动重装器 (Auto-reload):**
  - 如果开启了这个功能，当计数器减到 0 后，它会自动恢复成初始值（例如又变回 100），并继续传输。
  - 这通常用于**循环模式 (Circular Mode)**，比如音频播放或连续 ADC 采样，形成一个环形缓冲区。

### 4. 触发源选择 (中间下部)

DMA 什么时候开始搬运？这需要一个“发令枪”。

- 图中的梯形结构是一个 **多路复用器 (Mux)**，用来选择触发源：
  - **硬件触发 (Hardware Trigger):** 来自外设的信号。例如：ADC 转换完成、串口收到数据、定时器溢出。这是最常用的方式。
  - **软件触发 (Software Trigger):** 代码里手动让它开始，或者用于 M2M 模式（因为内存随时准备好，不需要等硬件信号，只要 CPU 说开始就开始）。
- **M2M 控制位:**
  - 由图可见，`M2M` 信号控制着选择器。
  - 如果是 M2M 模式，通常强制选择**软件触发**通道（走 1 路）。
  - 如果不是 M2M 模式，通常选择**硬件触发**通道（走 0 路）。

### 5. 开关控制 (右下角)

- **开关控制 (Enable Control):** 也就是 DMA 的使能位 (`DMA_Cmd`)。配置好上面所有参数后，必须打开这个开关，DMA 才会开始工作。

## DMA 在搬运数据时，“源端”和“目标端”的数据宽度（位数）不一样

![image-20251205004614739](.\assets\image-20251205004614739.png)

### 规则一：小数据搬到大空间 -> 高位补零

**场景**：源宽度 < 目标宽度 (例如 8位 -> 32位) 看表格的**第 2 行** (8 -> 16) 或 **第 3 行** (8 -> 32)。

- **现象**：
  - 源端有一个字节数据 `B0`。
  - 搬到目标端（16位）时，DMA 会自动把低位填上 `B0`，**高位全部补 0**，变成 `00B0`。
  - 搬到目标端（32位）时，变成 `000000B0`。
- **地址变化**：
  - 源地址每次 +1 (因为它一次只拿 8位)。
  - 目标地址每次 +2 或 +4 (因为它一次存 16位或 32位)。

### 规则二：大数据搬到小空间 -> 高位截断

**场景**：源宽度 > 目标宽度 (例如 16位 -> 8位) 看表格的**第 4 行** (16 -> 8) 或 **第 7 行** (32 -> 8)。

- **现象**：
  - 源端有两个字节数据 `B1B0` (16位)。
  - 搬到目标端（8位）时，DMA **只保留最低有效位 (LSB)**，也就是 `B0`。
  - **高位数据 `B1` 直接被丢弃了！**
- **地址变化**：
  - 源地址每次 +2 (因为它一次读 16位)。
  - 目标地址每次 +1 (因为它一次只写 8位)。

# USART串口

## 交叉连接 (TX 与 RX)

![image-20251205051754669](.\assets\image-20251205051754669.png)

- **TX (Transmit):** 发送端
- **RX (Receive):** 接收端
- **连接方式：**
  - **设备1 的 TX** $\rightarrow$ 接 $\rightarrow$ **设备2 的 RX** （设备1说，设备2听）
  - **设备1 的 RX** $\leftarrow$ 接 $\leftarrow$ **设备2 的 TX** （设备2说，设备1听）

## STM32F103 中的串口资源

- **USART1:** 挂载在 APB2 总线上（速度最快），通常用于下载程序或打印调试信息
  - TX: PA9
  - RX: PA10
- **USART2:** 挂载在 APB1 总线上
  - TX: PA2
  - RX: PA3
- **USART3:** 挂载在 APB1 总线上

> 使用 USB 转 TTL 模块 连接PC之后可以通信

## 协议

为了让 STM32 和电脑（或其他设备）能听懂对方在说什么，双方必须严格遵守的约定

### 波特率

这是通信的“语速”。表示每秒传输多少个二进制位（bit）。

- **常用值：** 9600, 115200 
- **规则：** 双方必须设置完全一致

### 数据帧格式

串口传输数据不是源源不断的，而是以“帧（Frame）”为单位，一次传输一个字符（或一个字节）。一个标准的通信帧包含以下部分：

1. **空闲状态 (Idle)：** 数据线在空闲时保持**高电平** (High)。
2. **起始位 (Start Bit)：** **1位**。发送方将电平拉**低**，告诉接收方：“注意，我要开始说话了”。
3. **数据位 (Data Bits)：** **通常是 8位**。这是实际传输的数据（比如字符 'A' 的 ASCII 码）。是低位在前，还是高位在前传输，这也是协议的一部分（通常是 LSB First，低位在前）。
4. **校验位 (Parity Bit)：** **通常选择“无 (None)”**。用于检查数据传输是否有错，也可以选奇校验或偶校验。
5. **停止位 (Stop Bit)：** **通常是 1位**。发送方将电平拉**高**，表示“这句话说完了”，回到空闲状态。

# Tera Term配置

![image-20251218211035032](.\assets\image-20251218211035032.png)

配置好之后点击确定，发现屏幕是黑的，然后点击上面菜单栏的`设置`-`串口`

![image-20251218211253884](.\assets\image-20251218211253884.png)

> 不太好用，使用XCOM更好

# I2C通信

## 总线结构

相比于串口的 TX/RX 交叉连接，I2C 是一种 **“总线 (Bus)”** 结构

- **SCL (Serial Clock):** 时钟线。永远由 **主机 (Master, 也就是 STM32)** 控制，像指挥棒一样打拍子
- **SDA (Serial Data):** 数据线。数据在这根线上双向传输（一会主机发，一会从机回）

可以在这两根线上挂 **很多个** 设备， STM32 接两根线出来，可以同时连着 `OLED、传感器、存储器... `只要它们的“名字”（地址）不一样，就不会打架

## 硬件I2C和软件I2C

| **特性**     | **硬件 I2C **                             | **软件 I2C **                              |
| ------------ | ----------------------------------------- | ------------------------------------------ |
| **原理**     | 使用 STM32 内部集成的 I2C 硬件电路        | 使用普通 GPIO 口，通过代码翻转电平模拟时序 |
| **引脚**     | **必须固定** (如 I2C1 只能是 PB6/PB7)     | **任意引脚** (随便找两个空闲的就行)        |
| **速度**     | 极快，且不占用 CPU 时间                   | 取决于 CPU 写代码的速度 (通常也足够快)     |
| **稳定性**   | STM32F103 的硬件 I2C 有设计缺陷，容易卡死 | **极其稳定**，代码写对了就永远不会错       |
| **代码难度** | 库函数配置极其繁琐，难调试                | **逻辑简单**，看着时序图就能写出来         |

> STM32F103 通常有两个硬件 I2C 接口：I2C1 和 I2C2

## I2C通信协议

==I2C协议中，有效数据流第一个字节是寄存器的地址，后面才是读写的数据==

### 开始与结束

I2C 总线在空闲时，SCL 和 SDA 都要保持 **高电平**（由上拉电阻拉高）。

#### ① 起始信号 (Start)

**含义：** “我要开始说话了！” **规则：** 当 SCL 保持 **高电平** 时，SDA 从高电平跳变到 **低电平**。

- 这是唯一一次在 SCL 为高电平时允许 SDA 变化的情况（除了停止信号）。

#### ② 停止信号 (Stop)

**含义：** “我说完了，释放总线。” **规则：** 当 SCL 保持 **高电平** 时，SDA 从低电平跳变到 **高电平**。

###  发送与接收一个字节

#### ③ 发送一个字节 (Send Byte)

**含义：** 主机把 8 位数据（比如 `0x35`）一位一位地发出去。 **规则（高位先行 MSB First）：**

- **准备数据：** SCL 拉低（允许 SDA 变化），主机把数据位（0或1）放到 SDA 上。
- **锁定数据：** SCL 拉高（告诉从机“快读”），保持一段时间。
- **循环：** 重复 8 次，发完 8 个位。

#### ④ 接收一个字节 (Receive Byte)

**含义：** 主机释放 SDA 线，让从机把数据放上来，主机去读取。 **规则：**

- **释放总线：** 主机先把 SDA 拉高（其实是释放，让从机能控制 SDA）。
- **读取数据：** SCL 拉高（此时从机已经把数据放好了），主机读取 SDA 的电平。
- **循环：** SCL 拉低，重复 8 次。

### 应答机制 (ACK)

每发送完一个字节（8位），第 9 位就是**应答位**。

#### ⑤ 发送应答 (Send ACK/NACK)

**场景：** 主机读取了从机的一个字节后，告诉从机：“我收到了，请继续发（ACK）”或者“够了，不要发了（NACK）”。

- **ACK (应答)：** 主机把 SDA 拉**低**。
- **NACK (非应答)：** 主机把 SDA 拉**高**。

#### ⑥ 等待应答 (Wait ACK)

**场景：** 主机发完一个字节给从机（比如发了地址），要看从机有没有“收到”。 **操作：**

1. 主机释放 SDA（拉高）。
2. 主机拉高 SCL。
3. **判断：** 此时主机去读 SDA 的电平。
   - 如果读到 **0 (低电平)**：说明从机把线拉低了，代表 **ACK (在)**。
   - 如果读到 **1 (高电平)**：说明没人理你，代表 **NACK (不在/出错了)**。



# SPI通信

## SPI 总线结构

SPI 是一种 **“4线全双工”** 的高速总线结构

- **SCK (Serial Clock):** 时钟线。由 **主机** (STM32) 控制。速度极快（可达 10MHz~50MHz），没有应答机制，主机说多快就是多快。
- **MOSI (Master Output Slave Input):** 主机输出 / 从机输入。主机给从机发数据的 **单行道**。
- **MISO (Master Input Slave Output):** 主机输入 / 从机输出。从机回传数据给主机的 **单行道**。
- **CS / SS (Chip Select / Slave Select):** 片选线。
  - **点名方式：** 不像 I2C 还要发地址，SPI 主机把这根线 **拉低**，从机就知道“轮到我了”。
  - **多从机：** 如果有 3 个从机，STM32 就需要 3 根 CS 线（CS1, CS2, CS3）分别连接它们。

## 硬件 SPI 和软件 SPI

| **特性**     | **硬件 SPI**                                    | **软件 SPI**                                   |
| ------------ | ----------------------------------------------- | ---------------------------------------------- |
| **原理**     | 使用 STM32 内部集成的 SPI 硬件外设              | 使用普通 GPIO 口，通过代码翻转电平模拟时序     |
| **引脚**     | **必须固定** (如 SPI1 是 PA5/6/7)               | **任意引脚** (随便找空闲的就行，CS 线更是随意) |
| **速度**     | **起飞** (可达 18MHz/36MHz)，适合刷屏幕/读卡    | **较慢** (取决于 CPU 翻转 GPIO 的速度)         |
| **稳定性**   | STM32 的硬件 SPI **非常稳定** (不像 I2C 有 Bug) | 极其稳定，逻辑简单，可移植性强                 |
| **代码难度** | 库函数配置较多，需理解 CPOL/CPHA 模式           | 逻辑简单，看着时序图就能写出来                 |

>  *STM32F103 通常有两个硬件 SPI 接口：SPI1 (高速) 和 SPI2 (低速)*

## SPI 通信协议

SPI 的核心逻辑不是“发送”或“接收”，而是 “交换 (Swap/Exchange)”。

主机和从机各有一个移位寄存器，时钟每跳 8 次，两者的数据就 同时 完成了互换。

![image-20251226090950053](.\assets\image-20251226090950053.png)

### 开始与结束

SPI 没有 I2C 那么复杂的起始/停止波形，全靠 **CS 片选线** 控制。

**① 起始信号 (Start)**

- **含义：** “被选中的从机请注意，通信开始。”
- **规则：** 主机将 CS 线从高电平 **拉低** (CS = 0)。

**② 停止信号 (Stop)**

- **含义：** “通信结束，从机去休息吧。”
- **规则：** 主机将 CS 线从低电平 **拉高** (CS = 1)。

### 交换一个字节 (Swap Byte)

SPI 是全双工的，**发送的同时一定在接收**。如果你只想发不想收，就忽略收到的数；如果你只想收不想发，就随便发个空数（如 0xFF）去置换。

**③ 交换字节的流程 (以最常用的 模式0 为例)**

- **含义：** 主机把自己的 8 位数据给从机，同时把从机的 8 位数据拿回来。
- **规则（高位先行 MSB First）：**
  1. **准备数据 (Output)：** 主机把数据最高位放在 MOSI 上，从机把数据最高位放在 MISO 上。
  2. **时钟上升沿 (Sampling)：** SCK 拉高。此时主机和从机同时 **读取** 对面线上的电平（读入数据）。
  3. **时钟下降沿 (Shifting)：** SCK 拉低。主机和从机同时 **移出** 下一位数据到线上。
  4. **循环：** 重复 8 次，完成一个字节的“大挪移”。

### 四种工作模式 (CPOL & CPHA)

不像 I2C 只有一种标准时序，SPI 有 4 种模式，**主机和从机必须配置成一样**才能通。

- **CPOL (Clock Polarity) 时钟极性：**
  - `0`: 空闲时 SCK 是低电平。
  - `1`: 空闲时 SCK 是高电平。
- **CPHA (Clock Phase) 时钟相位：**
  - `0`: 在第 1 个边沿（通常是上升沿）采样数据。
  - `1`: 在第 2 个边沿（通常是下降沿）采样数据。

> **最常用模式：** **Mode 0** (CPOL=0, CPHA=0) —— 空闲低电平，第 1 个边沿采样。





